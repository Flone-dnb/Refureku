/**
*	Copyright (c) 2020 Julien SOYSOUVANH - All Rights Reserved
*
*	This file is part of the Refureku library project which is released under the MIT License.
*	See the README.md file for full license details.
*/

#pragma once

#include <string>
#include <unordered_set>
#include <vector>
#include <type_traits>	//std::enable_if / std::is_invocable_r
#include <memory>		//std::shared_ptr

#include "Refureku/TypeInfo/Namespace/Namespace.h"
#include "Refureku/TypeInfo/Archetypes/Class.h"
#include "Refureku/TypeInfo/Archetypes/Enum.h"
#include "Refureku/TypeInfo/Archetypes/FundamentalArchetype.h"
#include "Refureku/Misc/FundamentalTypes.h"

namespace rfk
{
	class Database
	{
		friend class NamespaceFragmentRegisterer;
		friend class ArchetypeRegisterer;
		friend class DefaultEntityRegisterer;
		friend class ClassTemplateInstantiationRegisterer;
		friend REFUREKU_API Database const& getDatabase() noexcept;

		private:
			using EntitiesById					= std::unordered_set<Entity const*, Entity::PtrIdHasher, Entity::PtrEqualId>;
			using NamespacesByName				= std::unordered_set<Namespace const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using FundamentalArchetypesByName	= std::unordered_set<FundamentalArchetype const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using StructsByName					= std::unordered_set<Struct const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using ClassesByName					= std::unordered_set<Class const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using EnumsByName					= std::unordered_set<Enum const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using VariablesByName				= std::unordered_set<Variable const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using FunctionsByName				= std::unordered_multiset<Function const*, Entity::PtrNameHasher, Entity::PtrEqualName>;
			using GenNamespaces					= std::vector<std::shared_ptr<Namespace>>;

			/** Collection of all registered entities hashed by Id.  */
			EntitiesById				_entitiesById;

			/** Collection of all file level namespaces hashed by name. */
			NamespacesByName			_fileLevelNamespacesByName;

			/** Collection of all fundamental archetypes hashed by name. */
			FundamentalArchetypesByName	_fundamentalArchetypes;

			/** Collection of all file level structs hashed by name. */
			StructsByName				_fileLevelStructsByName;

			/** Collection of all file level classes hashed by name. */
			ClassesByName				_fileLevelClassesByName;

			/** Collection of all file level enums hashed by name. */
			EnumsByName					_fileLevelEnumsByName;

			/** Collection of all file level variables hashed by name. */
			VariablesByName				_fileLevelVariablesByName;

			/** Collection of all file level functions hashed by name. */
			FunctionsByName				_fileLevelFunctionsByName;

			/** Collection of namespace objects generated by the database. */
			GenNamespaces				_generatedNamespaces;

			/**
			*	@brief Get the (non-const) instance of the database.
			* 
			*	@return An instance of the database.
			*/
			static Database&			getInternal()														noexcept;

			/**
			*	@brief Register a file level entity to the database (add it to both _entitiesById & _fileLevelEntitiesByName).
			*	
			*	@param entity						The entity to register.
			*	@param shouldRegisterSubEntities	Should sub entities be registered by id recursively?
			*/
			void						registerFileLevelEntity(Entity const&	entity,
																bool			shouldRegisterSubEntities)	noexcept;

			/**
			*	@brief Register an entity to the database.
			*	
			*	@param entity						The entity to register.
			*	@param shouldRegisterSubEntities	Should sub entities be registered recursively?
			*/
			void						registerEntity(Entity const&	entity,
													   bool				shouldRegisterSubEntities)			noexcept;

			/**
			*	@brief Unregister an entity from the database.
			*	
			*	@param entity						The entity to unregister.
			*	@param shouldUnregisterSubEntities	Should sub entities be unregistered recursively?
			*/
			void						unregisterEntity(Entity const&	entity,
														 bool			shouldUnregisterSubEntities)		noexcept;

			/**
			*	@brief Add all nested entities to the _entitiesById map.
			*	
			*	@param s The parent struct.
			*/
			void						registerSubEntities(Struct const& s)								noexcept;

			/**
			*	@brief Remove all nested entities from the _entitiesById map.
			*	
			*	@param s The parent struct.
			*/
			void						unregisterSubEntities(Struct const& s)								noexcept;
			
			/**
			*	@brief Add all nested entities to the _entitiesById map.
			*	
			*	@param e The parent enum.
			*/
			void						registerSubEntities(Enum const& e)									noexcept;

			/**
			*	@brief Remove all nested entities from the _entitiesById map.
			*	
			*	@param e The parent enum.
			*/
			void						unregisterSubEntities(Enum const& e)								noexcept;

			/**
			*	@brief	Check that a namespace is still referenced by some namespace fragment.
			*			If not, remove it from the database.
			*
			*	@param npPtr Pointer to the namespace to check.
			*/
			void						checkNamespaceRefCount(std::shared_ptr<Namespace> const& npPtr)		noexcept;

			/**
			*	@brief Generate a namespace object to share between different namespace fragments.
			*	
			*	@param name Name of the namespace to generate.
			*	@param id Id of the namespace to generate.
			*
			*	@return The newly generated namespace.
			*/
			std::shared_ptr<Namespace>	generateNamespace(char const*	name,
														  std::size_t	id)									noexcept;

		public:
			Database()					= default;
			Database(Database const&)	= delete;
			Database(Database&&)		= delete;
			~Database()					= default;

			/**
			*	@brief Retrieve any entity of the program matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching entity.
			*	
			*	@return The first matching entity if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Entity const*>>>
			Entity const*				getEntity(Predicate predicate)									const;

			/**
			*	@brief Retrieve a file level namespace matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching namespace.
			*	
			*	@return The first matching namespace if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Namespace const*>>>
			Namespace const*			getNamespace(Predicate predicate)								const;

			/**
			*	@brief Retrieve a file level archetype matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching archetype.
			*	
			*	@return The first matching archetype if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Archetype const*>>>
			Archetype const*			getArchetype(Predicate predicate)								const;

			/**
			*	@brief Retrieve a file level struct matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching struct.
			*	
			*	@return The first matching struct if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Struct const*>>>
			Struct const*				getStruct(Predicate predicate)									const;

			/**
			*	@brief Retrieve a file level class matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching class.
			*	
			*	@return The first matching class if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Class const*>>>
			Class const*				getClass(Predicate predicate)									const;

			/**
			*	@brief Retrieve a file level enum matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching enum.
			*	
			*	@return The first matching enum if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Enum const*>>>
			Enum const*					getEnum(Predicate predicate)									const;

			/**
			*	@brief Retrieve a fundamental archetype matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching fundamental archetype.
			*	
			*	@return The first matching fundamental archetype if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, FundamentalArchetype const*>>>
			FundamentalArchetype const*	getFundamentalArchetype(Predicate predicate)					const;

			/**
			*	@brief Retrieve a file level variable matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching variable.
			*	
			*	@return The first matching variable if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Variable const*>>>
			Variable const*				getVariable(Predicate predicate)								const;

			/**
			*	@brief Retrieve a file level function matching with a given predicate.
			*	
			*	@param predicate Predicate returning true for any matching function.
			*	
			*	@return The first matching function if any is found, else nullptr.
			*/
			template <typename Predicate, typename = std::enable_if_t<std::is_invocable_r_v<bool, Predicate, Function const*>>>
			Function const*				getFunction(Predicate predicate)								const;

			/**
			*	@brief Retrieve a file level (non-member) function by name and signature.
			*	
			*	@tparam FunctionSignature Signature of the function to look for.
			*
			*	@param functionName The name of the function.
			*	@param flags		Flags describing the queried function.
			*						The result function will have at least the provided flags.
			*	
			*	@return A constant pointer to the function matching the signature, name and flags if it exists, else nullptr.
			*/
			template <typename FunctionSignature>
			Function const*				getFunction(std::string		functionName,
													EFunctionFlags	flags = EFunctionFlags::Default)	const	noexcept;

			/**
			*	@brief Retrieve an entity by id.
			*
			*	@param id The id of the entity.
			*
			*	@return A constant pointer to the queried entity if it exists, else nullptr.
			*/
			REFUREKU_API Entity const*					getEntity(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a namespace by id.
			*
			*	@param id The id of the namespace.
			*
			*	@return A constant pointer to the queried namespace if it exists, else nullptr.
			*/
			REFUREKU_API Namespace const*				getNamespace(std::size_t id)										const	noexcept;

			/**
			*	@brief	Retrieve a namespace by name.
			*			Can search nested namespaces directly using :: separator.
			*			Example: getNamespace("namespace1::namespace2") will get the namespace2 nested inside namespace1 if it exists.
			*
			*	@param namespaceName The name of the namespace.
			*
			*	@return A constant pointer to the queried namespace if it exists, else nullptr.
			*
			*	@exception BadNamespaceFormat if the provided namespace name has : instead of :: as a separator, or ends with :.
			*/
			REFUREKU_API Namespace const*				getNamespace(std::string namespaceName)								const;

			/**
			*	@brief Retrieve an archetype by id.
			*
			*	@param id The id of the archetype.
			*
			*	@return A constant pointer to the queried archetype if it exists, else nullptr.
			*/
			REFUREKU_API Archetype const*				getArchetype(std::size_t id)										const	noexcept;

			/**
			*	@brief	Retrieve a file level archetype by name.
			*			This method costs heavier performance as it will basically call getClass, getStruct, getEnum and then getFundamentalArchetype to find
			*			the queried archetype.
			*	
			*	@param archetypeName Name of the archetype.
			*
			*	@return A constant pointer to the queried archetype if it exists, else nullptr.
			*/
			REFUREKU_API Archetype const*				getArchetype(std::string archetypeName)								const	noexcept;

			

			/**
			*	@brief Retrieve a struct by id.
			*
			*	@param id The id of the struct.
			*
			*	@return A constant pointer to the queried struct if it exists, else nullptr.
			*/
			REFUREKU_API Struct const*					getStruct(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a file level struct by name.
			*
			*	@param structName The name of the struct.
			*
			*	@return A constant pointer to the queried struct if it exists, else nullptr.
			*/
			REFUREKU_API Struct const*					getStruct(std::string structName)									const	noexcept;

			/**
			*	@brief Retrieve a class by id.
			*
			*	@param id The id of the class.
			*
			*	@return A constant pointer to the queried class if it exists, else nullptr.
			*/
			REFUREKU_API Class const*					getClass(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a file level class by name.
			*
			*	@param className The name of the class.
			*
			*	@return A constant pointer to the queried class if it exists, else nullptr.
			*/
			REFUREKU_API Class const*					getClass(std::string className)										const	noexcept;

			/**
			*	@brief Retrieve an enum by id.
			*
			*	@param id The id of the enum.
			*
			*	@return A constant pointer to the queried enum if it exists, else nullptr.
			*/
			REFUREKU_API Enum const*					getEnum(std::size_t id)												const	noexcept;

			/**
			*	@brief Retrieve a file level enum by name.
			*
			*	@param enumName The name of the enum.
			*
			*	@return A constant pointer to the queried enum if it exists, else nullptr.
			*/
			REFUREKU_API Enum const*					getEnum(std::string enumName)										const	noexcept;

			/**
			*	@brief Retrieve a fundamental archetype by id.
			*
			*	@param id The id of the fundamental archetype.
			*
			*	@return A constant pointer to the queried fundamental archetype if it exists, else nullptr.
			*/
			REFUREKU_API FundamentalArchetype const*	getFundamentalArchetype(std::size_t id)								const	noexcept;

			/**
			*	@brief Retrieve a fundamental archetype by name.
			*
			*	@param archetypeName The name of the fundamental archetype.
			*
			*	@return A constant pointer to the queried fundamental archetype if it exists, else nullptr.
			*/
			REFUREKU_API FundamentalArchetype const*	getFundamentalArchetype(std::string archetypeName)					const	noexcept;

			

			/**
			*	@brief Retrieve a variable by id.
			*
			*	@param id The id of the variable.
			*
			*	@return A constant pointer to the queried variable if it exists, else nullptr.
			*/
			REFUREKU_API Variable const*				getVariable(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a file level (non-member) variable by name.
			*	
			*	@param variableName The name of the variable.
			*	@param flags		Flags describing the queried variable.
			*						The result variable will have at least the provided flags.
			*	
			*	@return A constant pointer to the queried variable if it exists, else nullptr.
			*/
			REFUREKU_API Variable const*				getVariable(std::string variableName,
																	EVarFlags	flags = EVarFlags::Default)					const	noexcept;

			

			/**
			*	@brief Retrieve a function by id.
			*
			*	@param id The id of the function.
			*
			*	@return A constant pointer to the queried function if it exists, else nullptr.
			*/
			REFUREKU_API Function const*				getFunction(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a file level (non-member) function by name.
			*	
			*	@param functionName The name of the function.
			*	@param flags		Flags describing the queried function.
			*						The result function will have at least the provided flags.
			*	
			*	@return A constant pointer to the first function matching the name and flags if it exists, else nullptr.
			*/
			REFUREKU_API Function const*				getFunction(std::string		functionName,
																	EFunctionFlags	flags = EFunctionFlags::Default)		const	noexcept;

			/**
			*	@brief Retrieve a method by id.
			*
			*	@param id The id of the method.
			*
			*	@return A constant pointer to the queried method if it exists, else nullptr.
			*/
			REFUREKU_API Method const*					getMethod(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a static method by id.
			*
			*	@param id The id of the static method.
			*
			*	@return A constant pointer to the queried static method if it exists, else nullptr.
			*/
			REFUREKU_API StaticMethod const*			getStaticMethod(std::size_t id)										const	noexcept;

			/**
			*	@brief Retrieve a field by id.
			*
			*	@param id The id of the field.
			*
			*	@return A constant pointer to the queried field if it exists, else nullptr.
			*/
			REFUREKU_API Field const*					getField(std::size_t id)											const	noexcept;

			/**
			*	@brief Retrieve a static field by id.
			*
			*	@param id The id of the static field.
			*
			*	@return A constant pointer to the queried static field if it exists, else nullptr.
			*/
			REFUREKU_API StaticField const*				getStaticField(std::size_t id)										const	noexcept;

			/**
			*	@brief Retrieve an enum value by id.
			*
			*	@param id The id of the enum value.
			*
			*	@return A constant pointer to the queried enum value if it exists, else nullptr.
			*/
			REFUREKU_API EnumValue const*				getEnumValue(std::size_t id)										const	noexcept;

			/**
			*	@brief Getter for _entitiesById.
			*
			*	@return _entitiesById.
			*/
			REFUREKU_API EntitiesById const&				getEntitiesById()			const	noexcept;

			/**
			*	@brief Getter for _fileLevelNamespacesByName.
			*
			*	@return _fileLevelNamespacesByName.
			*/
			REFUREKU_API NamespacesByName const&			getFileLevelNamespaces()	const	noexcept;

			/**
			*	@brief Getter for _fundamentalArchetypes.
			*
			*	@return _fundamentalArchetypes.
			*/
			REFUREKU_API FundamentalArchetypesByName const&	getFundamentalArchetypes()	const	noexcept;

			/**
			*	@brief Getter for _fileLevelStructsByName.
			*
			*	@return _fileLevelStructsByName.
			*/
			REFUREKU_API StructsByName const&				getFileLevelStructs()		const	noexcept;

			/**
			*	@brief Getter for _fileLevelClassesByName.
			*
			*	@return _fileLevelClassesByName.
			*/
			REFUREKU_API ClassesByName const&				getFileLevelClasses()		const	noexcept;

			/**
			*	@brief Getter for _fileLevelEnumsByName.
			*
			*	@return _fileLevelEnumsByName.
			*/
			REFUREKU_API EnumsByName const&					getFileLevelEnums()			const	noexcept;

			/**
			*	@brief Getter for _fileLevelVariablesByName.
			*
			*	@return _fileLevelVariablesByName.
			*/
			REFUREKU_API VariablesByName const&				getFileLevelVariables()		const	noexcept;

			/**
			*	@brief Getter for _fileLevelFunctionsByName.
			*
			*	@return _fileLevelFunctionsByName.
			*/
			REFUREKU_API FunctionsByName const&				getFileLevelFunctions()		const	noexcept;
	};

	/**
	*	@brief Get a reference to the database of this program.
	* 
	*	@return A reference to the database of this program.
	*/
	REFUREKU_API Database const& getDatabase() noexcept;

	#include "Refureku/TypeInfo/Database.inl"
}